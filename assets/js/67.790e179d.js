(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{474:function(a,e,s){"use strict";s.r(e);var t=s(20),n=Object(t.a)({},(function(){var a=this,e=a.$createElement,s=a._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"目前主流的访问权限控制-认证模式有以下几种："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目前主流的访问权限控制-认证模式有以下几种："}},[a._v("#")]),a._v(" 目前主流的访问权限控制/认证模式有以下几种：")]),a._v(" "),s("ol",[s("li",[a._v("Bearer Token（Token 令牌）")])]),a._v(" "),s("p",[a._v("定义：为了验证使用者的身份，需要客户端向服务器端提供一个可靠的验证信息，称为Token，这个token通常由Json数据格式组成，通过hash散列算法生成一个字符串，所以称为Json Web Token（Json表示令牌的原始值是一个Json格式的数据，web表示是在互联网传播的，token表示令牌，简称JWT)")]),a._v(" "),s("p",[s("strong",[a._v("JWT分为三部分：")])]),a._v(" "),s("p",[a._v("JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。")]),a._v(" "),s("p",[a._v("JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息。这显然增加了系统的可用性和伸缩性，大大减轻了服务端的压力。可以看出，JWT 更符合设计 RESTful API 时的「Stateless（无状态）」原则 。")]),a._v(" "),s("p",[a._v("并且， 使用 JWT 认证可以有效避免 CSRF 攻击，因为 JWT 一般是存在在 localStorage 中，使用 JWT 进行身份验证的过程中是不会涉及到 Cookie 的。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/system-design/jwt/jwt-composition.png",alt:"image"}})]),a._v(" "),s("p",[a._v("JWT 本质上就是一组字串，通过（.）切分成三个为 Base64 编码的部分：Header : 描述 JWT 的元数据，定义了生成签名的算法以及 Token 的类型。Payload : 用来存放实际需要传递的数据Signature（签名） ：服务器通过 Payload、Header 和一个密钥(Secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。")]),a._v(" "),s("p",[a._v("你可以在 jwt.io 这个网站上对其 JWT 进行解码，解码之后得到的就是 Header、Payload、Signature 这三部分。")]),a._v(" "),s("p",[a._v("Header 和 Payload 都是 JSON 格式的数据，Signature 由 Payload、Header 和 Secret(密钥)通过特定的计算公式和加密算法得到。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/system-design/jwt/jwt.io.png",alt:"image"}})]),a._v(" "),s("p",[s("strong",[a._v("Header")])]),a._v(" "),s("p",[a._v("Header 通常由两部分组成：")]),a._v(" "),s("p",[a._v("typ（Type）：令牌类型，也就是 JWT。\nalg（Algorithm） ：签名算法，比如 HS256。")]),a._v(" "),s("p",[a._v("示例：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("JSON 形式的 Header 被转换成 Base64 编码，成为 JWT 的第一部分。")]),a._v(" "),s("p",[s("strong",[a._v("Payload")])]),a._v(" "),s("p",[a._v("Payload 也是 JSON 格式数据，其中包含了 Claims(声明，包含 JWT 的相关信息)。Claims 分为三种类型：Registered Claims（注册声明） ：预定义的一些声明，建议使用，但不是强制性的。Public Claims（公有声明） ：JWT 签发方可以自定义的声明，但是为了避免冲突，应该在 IANA JSON Web Token Registryopen in new window 中定义它们。Private Claims（私有声明） ：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用。")]),a._v(" "),s("p",[a._v("下面是一些常见的注册声明：")]),a._v(" "),s("ul",[s("li",[a._v("iss（issuer）：JWT 签发方。")]),a._v(" "),s("li",[a._v("iat（issued at time）：JWT 签发时间。")]),a._v(" "),s("li",[a._v("sub（subject）：JWT 主题。")]),a._v(" "),s("li",[a._v("aud（audience）：JWT 接收方。")]),a._v(" "),s("li",[a._v("exp（expiration time）：JWT 的过期时间。")]),a._v(" "),s("li",[a._v("nbf（not before time）：JWT 生效时间，早于该定义的时间的 JWT 不能被接受处理。")]),a._v(" "),s("li",[a._v("jti（JWT ID）：JWT 唯一标识。")])]),a._v(" "),s("p",[a._v("示例：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('{\n  "uid": "ff1212f5-d8d1-4496-bf41-d2dda73de19a",\n  "sub": "1234567890",\n  "name": "John Doe",\n  "exp": 15323232,\n  "iat": 1516239022,\n  "scope": ["admin", "user"]\n}\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("p",[a._v("Payload 部分默认是不加密的，一定不要将隐私信息存放在 Payload 当中！！！")]),a._v(" "),s("p",[a._v("JSON 形式的 Payload 被转换成 Base64 编码，成为 JWT 的第二部分。")]),a._v(" "),s("p",[s("strong",[a._v("Signature")])]),a._v(" "),s("p",[a._v("Signature 部分是对前两部分的签名，作用是防止 JWT（主要是 payload） 被篡改。这个签名的生成需要用到：Header + Payload。存放在服务端的密钥(一定不要泄露出去)。签名算法。签名的计算公式如下：")]),a._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v('HMACSHA256(\n  base64UrlEncode(header) + "." +\n  base64UrlEncode(payload),\n  secret)\n')])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v('算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用"点"（.）分隔，这个字符串就是 JWT 。')]),a._v(" "),s("h3",{attrs:{id:"如何基于-jwt-进行身份验证？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何基于-jwt-进行身份验证？"}},[a._v("#")]),a._v(" 如何基于 JWT 进行身份验证？")]),a._v(" "),s("p",[a._v("在基于 JWT 进行身份验证的的应用程序中，服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/jwt/jwt-authentication%20process.png",alt:"image"}})]),a._v(" "),s("p",[a._v("简化后的步骤如下：")]),a._v(" "),s("ol",[s("li",[a._v("用户向服务器发送用户名、密码以及验证码用于登陆系统。")]),a._v(" "),s("li",[a._v("如果用户用户名、密码以及验证码校验正确的话，服务端会返回已经签名的 Token，也就是 JWT。")]),a._v(" "),s("li",[a._v("用户以后每次向后端发请求都在 Header 中带上这个 JWT 。")]),a._v(" "),s("li",[a._v("服务端检查 JWT 并从中获取用户相关信息。")])]),a._v(" "),s("p",[a._v("两点建议：")]),a._v(" "),s("ol",[s("li",[a._v("建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。")]),a._v(" "),s("li",[a._v("请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 Authorization 字段中（Authorization: Bearer Token）。")])]),a._v(" "),s("h3",{attrs:{id:"如何防止-jwt-被篡改？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何防止-jwt-被篡改？"}},[a._v("#")]),a._v(" 如何防止 JWT 被篡改？")]),a._v(" "),s("p",[a._v("有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature 、Header 、Payload。")]),a._v(" "),s("p",[a._v("这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。")]),a._v(" "),s("p",[a._v("不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature 、Header 、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了。")]),a._v(" "),s("p",[a._v("密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。")]),a._v(" "),s("h3",{attrs:{id:"如何加强-jwt-的安全性？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何加强-jwt-的安全性？"}},[a._v("#")]),a._v(" 如何加强 JWT 的安全性？")]),a._v(" "),s("ol",[s("li",[a._v("使用安全系数高的加密算法。")]),a._v(" "),s("li",[a._v("使用成熟的开源库，没必要造轮子。")]),a._v(" "),s("li",[a._v("JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。")]),a._v(" "),s("li",[a._v("一定不要将隐私信息存放在 Payload 当中。")]),a._v(" "),s("li",[a._v("密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。")]),a._v(" "),s("li",[a._v("Payload 要加入 exp （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);