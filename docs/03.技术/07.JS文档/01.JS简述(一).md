---
title: JS简述（一）
date: 2021-01-22 13:44:01
categories: 
  - 技术
  - JS文档
tags: 
  - null
author: null
permalink: /pages/1c64a2/
---

# JS基础文档

JS基础梳理(一)

# 一、类型

## 1. 基础类型和引用类型

- 基础类型有：number string boolean null undefined symbol bight
- 引用类型：object array function...

## 2.类型检测

### typeOf 和 instanceOf

- typeOf可以判断基础类型、判断对象类型时，除了函数 其他都是 `object`
- instanceOf 可以判断对象类型，原理是通过原型链查找原型对象

### Object.prototype.toString.call()

### instanceOf原理手写实现

```js
const myInstanceOf = (a, A) {
  if(typeOf a !== 'object') {
      return false
  }
  if(a._proto_ === A.prototype) {
    return true
  }
  return myInstanceOf(a._proto_, A)
} 
```

**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。

**语法**

> ```javascript
> object instanceof constructor
> ```

# 二、闭包

## 作用域链

**什么是闭包**

闭包是指有权访问另外一个作用域中变量的函数。

### 为什么会有闭包

作用域有 全局作用域和函数作用域。内层函数会将拷贝外层的作用域，与自己的作用域一起形成作用域链。作用域链链保证了执行环境对变量的有序访问，当在当前环境内没有找到的变量，就会去父级作用域查找

# 三、原型链

**如何理解原型链**

- 构造函数有一个prototype指向原型对象
- 原型对象所具有的属性和方法会被构造函数的所有实例共享
- 实例对象有一个\_proto_属性指向了原型对象
- 原型对象有自己的\_proto_指向了它的原型对象，因此就形成了原型链

# 四、继承

- 常用的实现继承的几种方式

## 1、借用call

```js
function Parent(){
  this.name = `parent1`;
}

function Child() {
  Parent.call(this)
  this.type = 'child'
}
```

缺点：没办法继承父类的方法

## 2、借用原型链

```js
function Parent(){
  this.name = `parent1`;
  this.play = [1,2,3]
}

function Child() {
  this.type = 'child'
}

Child.prototype = new Parent()
```

缺点：继承的属性会被所有实例共享

## 3、call 和原型链组合

```js
function Parent(){
  this.name = `parent1`;
  this.play = [1,2,3]
}

function Child() {
  Parent.call(this)
  this.type = 'child'
}

Child.prototype = new Parent()
```

缺点: Parent的构造函数会被重复调用。

## 4、组合方式优化

```js
function Parent(){
  this.name = `parent1`;
  this.play = [1,2,3]
}

function Child() {
  Parent.call(this)
  this.type = 'child'
}

Child.prototype = Parent.prototype
```

缺点： Child.prototype.constructor 指向了Parent

## 5、寄生组合(完美方案)

```js
function Parent(){
  this.name = `parent1`;
  this.play = [1,2,3]
}

function Child() {
  Parent.call(this)
  this.type = 'child'
}

Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child
```

# 函数的arguments/this

## arguments

### 1. argumrnts是不是数组

不是数组、是一个类数组对象。它的key从0开始依次递增。并且有length属性，但是没有数组的诸多工具方法

### 2.如何转成数组

```js
  1. 通过Array.form
  2. 通过结构赋值 [...arguments]
  3. Array.prototype.slice.call(arguments)
  4. Array.prototype.concat.apply([], arguments)
```

## this的指向

**各种场景下的this指向**

- 全局上下文的this指向window，严格模式下为undefined
- 直接调用函数与全局上下文一致
- `对象.方法`的方式，`this`指向这个对象
- DOM事件绑定： `onclick` 和 `addEventerListener`中`this`指向绑定事件的元素 IE浏览器中的attachEvent，`this`指向window
- new+构造函数，构造函数中的`this`指向实例对象
- 箭头函数没有自己的this，也不能绑定，箭头函数中的`this`指向构造时上下文环境的`this`

**手动实现new**

- 创建一个空对象
- apply一下构造函数
- 将obj的`_proto_`指向构造函数的prototype
- 如果函数的执行结果返回一个对象，则返回该对象，否则返回obj

```js
function myNew(){
	// 创建obj
  const obj = new Object();
  // 获取第一个参数，arguments是类数组，不可直接调用shift方法
  // 此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数
  const Constructor = [].shift.call(arguments);
  // 将构造函数的this指向obj，这样就可以访问到构造函数中的属性
  const res = Constructor.apply(obj,arguments);
  if(typeOf res === 'object' || typeOf res === 'function'){
    return res;
  }
  // 将obj的原型指向构造函数的原型对象，这样ob就可以访问构造函数原型上的属性
  obj.__proto__= Object.create(Constructor.prototype);
  return obj;
}
```

### eval

> eval() 函数用来执行一个字符串表达式，并返回表达式的值。

